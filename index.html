<!doctype html><html lang="PL"><head><meta charset="UTF-8"><title>Mariusz Najwer</title><meta name="viewport" content="width=device-width,initial-scale=1"/><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/><meta name="author" content="Mariusz Najwer"><meta name="description" content="Mariusz Najwer - TSP"/><meta name="keywords" content="Mariusz Najwer, najwer23"/><link rel="icon" href="f.png"><script defer="defer" src="style.bunde.js"></script><script defer="defer" src="dataIn.bunde.js"></script><script defer="defer" src="index.bunde.js"></script><script defer="defer" src="drawChart.bunde.js"></script><link href="style.css" rel="stylesheet"></head><body><main><h1>The traveling salesman problem with Simulated Annealing (Euclidean distance)</h1><p>The traveling salesman problem is a classic problem in combinatorial optimization. This problem is to find the shortest path that a salesman should take to traverse through a list of cities and return to the origin city. The list of cities and the distance between each pair are provided.<br><br>TSP is useful in various applications in real life such as planning or logistics. For example, a concert tour manager who wants to schedule a series of performances for the band must determine the shortest path for the tour to ensure reducing traveling costs and not making the band unnecessarily exhausted.<br><br>This is an <b>NP-hard</b> problem. In simple words, it means you can not guarantee to find the shortest path within a reasonable time limit. This is not unique to TSP though. In real-world optimization problems, you frequently encounter problems for which you must find sub-optimal solutions instead of optimal ones.<br><br>The obvious way to solve the travelling salesman problem would be to write down all of the possible sequences in which the cities could be visited, compute the distance of each path, and then choose the smallest. But the number of possible itineraries for visiting n cities grows as the factorial of n, which is written, appropriately, as “n!”. The factorial of a positive integer is the product of that number and all smaller numbers down to one. Hence 2!=2, 3!=6, 6!=720, and 10!=3,628,800. As you can see, these numbers grow very rapidly, so as you increase the number of cities, the number of paths you have to compare blows up in a combinatorial explosion which makes finding the optimal path by brute force computation a hopeless undertaking.<br><br>The number of possible paths along which we can visit the thirty cities is equal to the number of permutations of a set of thirty distinct members, which is equal to the factorial of the number of members, or 30!. This is a breathtakingly large number.<br><br>30! = 265,252,859,812,191,058,636,308,480,000,000 ≈ 2.6525×10<sup>32</sup></p><p class="source">https://www.fourmilab.ch/documents/travelling/anneal/<br>https://towardsdatascience.com/how-to-solve-the-traveling-salesman-problem-a-comparative-analysis-39056a916c9f</p><p></p><h2>Simulated Annealing</h2><p>Simulated Annealing or SA is a heuristic search algorithm that is inspired by the annealing mechanism in the metallurgy industry. Annealing refers to a controlled cooling mechanism that leads to the desired state of the material.<br><br>By analogy with the process of annealing a material such as metal or glass by raising it to a high temperature and then gradually reducing the temperature, allowing local regions of order to grow outward, increasing ductility and reducing stresses in the material, the algorithm randomly perturbs the original path to a decreasing extent according to a gradually decreasing logical “temperature”.<br><br><b>Definition</b><br>Simulated annealing (SA) is a probabilistic technique for approximating the global optimum of a given function. Specifically, it is a metaheuristic to approximate global optimization in a large search space for an optimization problem. It is often used when the search space is discrete (for example the traveling salesman problem, the boolean satisfiability problem, protein structure prediction, and job-shop scheduling). For problems where finding an approximate global optimum is more important than finding a precise local optimum in a fixed amount of time, simulated annealing may be preferable to exact algorithms such as gradient descent or branch and bound.</p><div class="wrapper-img"><img src="assets/img/search.gif"/><p class="desc">Simulated annealing searching for a maximum. The objective here is to get to the highest point. In this example, it is not enough to use a simple hill climb algorithm, as there are many local maxima. By cooling the temperature slowly the global maximum is found.</p></div><p class="source">Press, William H., Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numerical Recipes in C, 2nd ed. Cambridge: Cambridge University Press, [1988] 1992. ISBN 978-0-521-43108-8. Section 10.9, pp. 444–451. (A third edition of this book with algorithms in C++ is available.)</p><h2>Programming stuff</h2><p><b>Problem:</b><br>What is the shortest itinerary which will visit every city exactly once and return to the point of origin? <b><br><br>Solution</b><br><br>- Towns can be nodes (points) in Cartesian xy coordinate system.<br>- Route between cities can be edge.<br>- We can calculate distance between cities<br>- Suppose the earth is flat (Always do approximation if You can)<br>- We don't know which tempearture and cooling we should choose. It can't be the best and can't be the worst. Should be just fine. We can figure out it be testing our model</p><br>Example 1<br>Graph have been drawing with html Canvas, more about data used here You can find in console (f12)<div class="canvas-wrapper"><div class="canvas-box"><canvas id="test1"></canvas></div><p>7 points on map, and shortstes path.</p></div>Example 2<br>Graph have been drawing with html Canvas, more about data used here You can find in console (f12)<div class="canvas-wrapper"><div class="canvas-box"><canvas id="test2"></canvas></div><p>8 points on map, and shortstes path.</p></div><h2>Tech</h2>- HTML Canvas, CSS3, JavaScript, Webpack, yarn<h2>Repo</h2>https://github.com/najwer23/tsp<br><br>https://twitter.com/najwer23<br>https://najwer23.github.io/<br><br><br></main></body></html>